<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Babylon.js sample code</title>

    <!-- Babylon.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>

    <style>
        html,
        body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");
        var walked = false;
        var hero = null;

        var engine = null;
        var scene = null;
        var sceneToRender = null;
        var createDefaultEngine = function () {
            return new BABYLON.Engine(canvas, true, {
                preserveDrawingBuffer: true,
                stencil: true,
                disableWebGL2Support: false,
            });
        };

        var general;

        const createScene = function () {
            const scene = new BABYLON.Scene(engine);

            general = new BABYLON.Mesh("general", scene);

            var camera1 = new BABYLON.ArcRotateCamera(
                "camera1",
                Math.PI / 2,
                Math.PI / 4,
                10,
                new BABYLON.Vector3(0, -5, 0),
                scene
            );
            scene.activeCamera = camera1;
            scene.activeCamera.attachControl(canvas, true);
            // camera1.lowerRadiusLimit = 2;
            // camera1.upperRadiusLimit = 10;
            camera1.wheelDeltaPercentage = 0.01;

            // Lights
            var light = new BABYLON.HemisphericLight(
                "light1",
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            light.intensity = 0.6;
            light.specular = BABYLON.Color3.Black();

            var light2 = new BABYLON.DirectionalLight(
                "dir01",
                new BABYLON.Vector3(0, -0.5, -1.0),
                scene
            );
            light2.position = new BABYLON.Vector3(0, 5, 5);
            //Skybox
            var skybox = BABYLON.MeshBuilder.CreateBox(
                "skybox",
                { size: 500 },
                scene
            );
            skybox.infiniteDistance = true;
            var skyboxMaterial = new BABYLON.StandardMaterial("skybox", scene);
            skyboxMaterial.backFaceCulling = false;
            var files = [
                "./img/sky.jpg",
                "./img/sky.jpg",
                "./img/sky.jpg",
                "./img/sky.jpg",
                "./img/sky.jpg",
                "./img/sky.jpg",
            ];
            skyboxMaterial.reflectionTexture = BABYLON.CubeTexture.CreateFromImages(
                files,
                scene
            );
            skyboxMaterial.reflectionTexture.coordinatesMode =
                BABYLON.Texture.SKYBOX_MODE;
            skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            skybox.material = skyboxMaterial;
            // const skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 150 }, scene);
            // const skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
            // skyboxMaterial.backFaceCulling = false;
            // skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("./img/sky.jpg", scene);
            // skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
            // skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
            // skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            // skybox.material = skyboxMaterial;

            // Enable physics
            scene.enablePhysics();

            //Create large ground for valley environment
            const largeGroundMat = new BABYLON.StandardMaterial("largeGroundMat");
            largeGroundMat.diffuseTexture = new BABYLON.Texture(
                "https://assets.babylonjs.com/environments/valleygrass.png"
            );

            const largeGround = BABYLON.MeshBuilder.CreateGroundFromHeightMap(
                "largeGround",
                "./img/map3.jpg",
                {
                    width: 250,
                    height: 250,
                    subdivisions: 10,
                    minHeight: 0,
                    maxHeight: 40,
                }
            );
            largeGround.material = largeGroundMat;

            // add fisica ao chão
            largeGround.physicsImpostor = new BABYLON.PhysicsImpostor(
                largeGround,
                BABYLON.PhysicsImpostor.BoxImpostor,
                { mass: 0, friction: 0.5, restitution: 0.7 },
                scene
            );

            // Keyboard events
            var inputMap = {};
            scene.actionManager = new BABYLON.ActionManager(scene);
            scene.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnKeyDownTrigger,
                    function (evt) {
                        inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
                    }
                )
            );
            scene.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnKeyUpTrigger,
                    function (evt) {
                        inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
                    }
                )
            );

            // Load hero character
            BABYLON.SceneLoader.ImportMesh(
                "",
                "https://assets.babylonjs.com/meshes/",
                "HVGirl.glb",
                scene,
                function (newMeshes, particleSystems, skeletons, animationGroups) {
                    hero = newMeshes[0];

                    hero.name = "hero";
                    // console.log("hero.name")
                    // console.log(hero.name)

                    //Scale the model down
                    hero.scaling.scaleInPlace(0.1);

                    //Lock camera on the character
                    camera1.target = hero;

                    //Hero character variables
                    var heroSpeed = 0.03;
                    var heroSpeedBackwards = 0.01;
                    var heroRotationSpeed = 0.1;

                    var animating = true;

                    scene.addMesh(hero);

                    const walkAnim = scene.getAnimationGroupByName("Walking");
                    const walkBackAnim = scene.getAnimationGroupByName("WalkingBack");
                    const idleAnim = scene.getAnimationGroupByName("Idle");
                    const sambaAnim = scene.getAnimationGroupByName("Samba");

                    //Rendering loop (executed for everyframe)
                    scene.onBeforeRenderObservable.add(() => {
                        var keydown = false;
                        walked = false;
                        //Manage the movements of the character (e.g. position, direction)
                        if (inputMap["w"]) {
                            hero.moveWithCollisions(hero.forward.scaleInPlace(heroSpeed));
                            keydown = true;
                            walked = true;
                        }
                        if (inputMap["s"]) {
                            hero.moveWithCollisions(
                                hero.forward.scaleInPlace(-heroSpeedBackwards)
                            );
                            keydown = true;
                            walked = true;
                        }
                        if (inputMap["a"]) {
                            hero.rotate(BABYLON.Vector3.Up(), -heroRotationSpeed);
                            keydown = true;
                            walked = true;
                        }
                        if (inputMap["d"]) {
                            hero.rotate(BABYLON.Vector3.Up(), heroRotationSpeed);
                            keydown = true;
                            walked = true;
                        }
                        if (inputMap["b"]) {
                            keydown = true;
                            walked = true;
                        }

                        //Manage animations to be played
                        if (keydown) {
                            if (!animating) {
                                animating = true;
                                if (inputMap["s"]) {
                                    //Walk backwards
                                    walkBackAnim.start(
                                        true,
                                        1.0,
                                        walkBackAnim.from,
                                        walkBackAnim.to,
                                        false
                                    );
                                } else if (inputMap["b"]) {
                                    //Samba!
                                    sambaAnim.start(
                                        true,
                                        1.0,
                                        sambaAnim.from,
                                        sambaAnim.to,
                                        false
                                    );
                                } else {
                                    //Walk
                                    walkAnim.start(
                                        true,
                                        1.0,
                                        walkAnim.from,
                                        walkAnim.to,
                                        false
                                    );
                                }
                            }

                            
                        } else {
                            if (animating) {
                                //Default animation is idle when no key is down
                                idleAnim.start(true, 1.0, idleAnim.from, idleAnim.to, false);

                                //Stop all animations besides Idle Anim when no key is down
                                sambaAnim.stop();
                                walkAnim.stop();
                                walkBackAnim.stop();

                                //Ensure animation are played only once per rendering loop
                                animating = false;
                            }
                        }
                    });



                }
            );

            scene.registerBeforeRender(function () {
                // const hero = scene.getMeshByName("hero");
                // console.log(hero); // não sei mas não pega o hero aqui fora

                // if (hero.intersectsMesh(scene.getMeshByName("house1"), true)) {
                //     console.log("colidiu");
                // }

                // //Balloon 1 intersection -- Precise = false
                // if (balloon1.intersectsMesh(plan1, false)) {
                //     balloon1.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
                // } else {
                //     balloon1.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                // }

                // //Balloon 2 intersection -- Precise = true
                // if (balloon2.intersectsMesh(plan2, true)) {
                //     balloon2.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
                // } else {
                //     balloon2.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                // }

                // //balloon 3 intersection on single point
                // if (balloon3.intersectsPoint(pointToIntersect)) {
                //     balloon3.material.emissiveColor = new BABYLON.Color3(1, 0, 0);
                // } else {
                //     balloon3.material.emissiveColor = new BABYLON.Color3(1, 1, 1);
                // }

                // alpha += 0.01;
                // balloon1.position.y += Math.cos(alpha) / 10;
                // balloon2.position.y = balloon1.position.y;
                // balloon3.position.y = balloon1.position.y;
                // var tes = scene.getMeshByName("hero");
                // // // var tes2 = scene.getMeshByName("barriu");
                // console.log("tes")
                // console.log(tes._position)
                // // console.log(scene.getMeshByName("hause1"))
            });

            buildVille();
            multipleBarrel(scene, 30);

            //pegar get por nome, da para usar isso para fazer os collider
            console.log(scene.getMeshByName("hero"))

            return scene;
        };

        const multipleBarrel = (scene, qtd) => {
            var min1, min2, max1, max2;
            min1 = min2 = 5;
            max1 = max2 = 30;
            for (let i = 0; i < qtd; i++) {
                if (i % 2 == 0) {
                    min1 *= -1;
                    max2 *= -1;
                } else {
                    max1 *= -1;
                    min2 *= -1;
                }
                var a = Math.random() * (max1 - min1) + min1;
                var b = Math.random() * (max2 - min2) + min2;
                buildBarrel(scene, a, b);
            }
        }
        const buildVille = () => {
            // primeiro numero é o ID, para identificar os nomes dos meshes
            buildHouse(1, 0, 0, 0);
            buildHouse(2, -10, 0, 2);
            buildHouse(3, 0, 20, 4);
            buildHouse(4, -5, -10, 1);
            buildHouse(5, -10, 20, 6);
        }

        const buildHouse = (id, posx, posz, roty) => {
            var newMesh = new BABYLON.Mesh(`house${id}`, scene);
            newMesh.addChild(buildBox(id));
            newMesh.addChild(buildRoof(id));
            newMesh.position.x = posx;
            newMesh.position.z = posz;
            newMesh.rotation.y = roty;
            return newMesh;
        };

        const buildBox = (id) => {
            //texture
            const boxMat = new BABYLON.StandardMaterial("boxMat");
            boxMat.diffuseTexture = new BABYLON.Texture(
                "https://assets.babylonjs.com/environments/cubehouse.png"
            );

            //options parameter to set different images on each side
            const faceUV = [];
            faceUV[0] = new BABYLON.Vector4(0.6, 0.0, 1.0, 1.0); //rear face
            faceUV[1] = new BABYLON.Vector4(0.0, 0.0, 0.4, 1.0); //front face
            faceUV[2] = new BABYLON.Vector4(0.4, 0, 0.6, 1.0); //right side
            faceUV[3] = new BABYLON.Vector4(0.4, 0, 0.6, 1.0); //left side
            // top 4 and bottom 5 not seen so not set

            /**** World Objects *****/
            const box = BABYLON.MeshBuilder.CreateBox(`boxHouse${id}`, {
                width: 12,
                height: 8,
                depth: 5,
                faceUV: faceUV,
                wrap: true,
            });
            box.material = boxMat;
            box.position.y = 4;
            box.position.x = 22;
            return box;
        };

        const buildRoof = (id) => {
            //texture
            const roofMat = new BABYLON.StandardMaterial("roofMat");
            roofMat.diffuseTexture = new BABYLON.Texture(
                "https://assets.babylonjs.com/environments/roof.jpg"
            );

            const roof = BABYLON.MeshBuilder.CreateCylinder(`roofHouse${id}`, {
                diameter: 6,
                height: 12.2,
                tessellation: 3,
            });
            roof.material = roofMat;
            roof.scaling.x = 0.75;
            roof.rotation.z = Math.PI / 2;
            roof.position.y = 9;
            roof.position.x = 22;
            return roof;
        };

        const buildBarrel = (scene, posx, posz) => {
            BABYLON.SceneLoader.ImportMesh(
                "",
                "https://models.babylonjs.com/",
                "ExplodingBarrel.glb",
                scene,
                function (newMeshes, particleSystems, skeletons, animationGroups) {
                    var barrel = newMeshes[0];

                    barrel.position.x = posx;
                    barrel.position.z = posz;

                    const cylinder = BABYLON.MeshBuilder.CreateCylinder("cBarrel", { height: 3 });

                    cylinder.position = barrel.position;
                    cylinder.addChild(barrel);
                    cylinder.isVisible = false;

                    var explosied = false;
                    scene.onBeforeRenderObservable.add(() => {
                        if (!explosied) {
                            if (cylinder.intersectsMesh(hero, true)) {
                                if (walked) {
                                    setExplosion(barrel, cylinder, hero._position);
                                    explosied = true;
                                }
                            }
                        }
                    });

                    barrel.scaling.scaleInPlace(0.02);

                    scene.addMesh(barrel);
                }
            );
        };

        const setExplosion = function (barrel, cylinder, position) {
            

            // Make explosion sound
            const bounce = new BABYLON.Sound("bounce", "./sounds/Explosion-with-Metal-Debris.mp3", scene,
                null, {
                    loop: false,
                    autoplay: true
                });

            // Generate particules
            setParticules(position);

            // exclude barrel
            barrel.dispose();
            cylinder.dispose();
        }

        const setParticules = function (position) {
            console.log(position)
            var count = 0;
            BABYLON.ParticleHelper.CreateAsync("explosion", scene).then((set) => {
                set.systems.forEach(s => {
                    s.emitter = new BABYLON.Vector3(position.x, position.y, position.z);
                    s.disposeOnStop = true;
                });
                set.start();
            });          
        }

        window.initFunction = async function () {
            var asyncEngineCreation = async function () {
                try {
                    return createDefaultEngine();
                } catch (e) {
                    console.log(
                        "the available createEngine function failed. Creating the default engine instead"
                    );
                    return createDefaultEngine();
                }
            };

            window.engine = await asyncEngineCreation();
            if (!engine) throw "engine should not be null.";
            window.scene = createScene();
        };
        initFunction().then(() => {
            sceneToRender = scene;
            engine.runRenderLoop(function () {
                if (sceneToRender && sceneToRender.activeCamera) {
                    sceneToRender.render();
                }
            });
        });

        // Resize
        window.addEventListener("resize", function () {
            engine.resize();
        });
    </script>
</body>

</html>